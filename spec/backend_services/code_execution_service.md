# Code Execution Service — Detailed Design

> File: `backend/app/services/code_execution_service.py`

## Responsibility

Execute arbitrary Python code generated by the LLM in the chatbot's `execute_python` tool. Capture stdout, stderr, exit code, and generated images. Enforce execution timeouts.

---

## Security Context

The application runs entirely within an isolated virtual machine. There is no sensitive data or network access that needs protection beyond the VM boundary. Therefore, code execution does not require sandboxing beyond basic timeout enforcement. The LLM-generated code runs in the same Python process as the FastAPI backend.

---

## Execution Method

Code is executed using Python's `exec()` function within a controlled namespace. This approach is chosen over subprocess-based execution for simplicity and because the isolated VM context eliminates security concerns.

### Execution Environment

The execution namespace is pre-populated with common data analysis imports and references to application data:

```python
EXECUTION_GLOBALS = {
    "__builtins__": __builtins__,
    "pd": pandas,
    "np": numpy,
    "plt": matplotlib.pyplot,
    "sns": seaborn,
    "scipy": scipy,
    "xgboost": xgboost,
}
```

Additionally, a helper object is injected that provides convenient access to the application's data files:

```python
class DataContext:
    data_dir: str = "/app/data"
    meter_sept: str = "/app/data/meter-data-sept-2025.csv"
    meter_oct: str = "/app/data/meter-data-oct-2025.csv"
    buildings: str = "/app/data/building_metadata.csv"
    weather: str = "/app/data/weather-sept-oct-2025.csv"
```

This is exposed as `data` in the execution namespace, so the LLM can write `pd.read_csv(data.meter_sept)`.

---

## Public Methods

### `execute(code: str, timeout: int = 30) -> ExecutionResult`

Executes the given Python code string and returns the result.

Steps:

1. Create a `StringIO` capture for stdout and stderr.
2. Set up the execution namespace with pre-populated globals.
3. Redirect `sys.stdout` and `sys.stderr` to the capture buffers.
4. Set up matplotlib to use the `Agg` backend (non-interactive) and clear any existing figures.
5. Execute the code via `exec(code, namespace)` within a thread with a timeout.
6. After execution, check for any open matplotlib figures. If found, save each to a PNG buffer and encode as base64 data URIs.
7. Restore stdout/stderr.
8. Return the `ExecutionResult`.

### Timeout Enforcement

Code execution runs in a separate thread using `concurrent.futures.ThreadPoolExecutor`. The main thread waits for completion with a configurable timeout (default 30 seconds). If the timeout is exceeded:

1. The thread is left running (Python threads cannot be forcefully terminated, but the thread will eventually complete or be cleaned up on process exit).
2. The result is returned with exit code 1, stderr containing "Execution timed out after N seconds", and empty stdout/images.

For a production system, subprocess-based execution with process kill would be preferred. For the hackathon prototype, thread-based timeout is acceptable.

---

## Result Type

```python
@dataclass
class ExecutionResult:
    stdout: str          # Captured print output
    stderr: str          # Captured error output
    exit_code: int       # 0 for success, 1 for error
    images: list[str]    # Base64-encoded PNG data URIs
    execution_time: float  # Wall clock time in seconds
```

---

## Image Capture

After code execution, the service checks `matplotlib.pyplot.get_fignums()` for any open figures. Each figure is saved to a `BytesIO` buffer as PNG, then encoded as a base64 data URI:

```
data:image/png;base64,iVBORw0KGgo...
```

The figures are closed after capture. The frontend displays these as inline `<img>` elements in the tool invocation block.

If the code explicitly calls `plt.savefig()` to a file path, those files are not captured — only figures that remain in memory are captured. The system prompt should instruct the LLM to use `plt.show()` rather than `plt.savefig()`.

---

## Error Handling

- **Syntax errors**: Caught by `exec()` and reported in stderr with the full traceback.
- **Runtime errors**: Caught by a try/except wrapper. Traceback is captured in stderr.
- **Import errors**: If the LLM tries to import unavailable packages, the ImportError is captured in stderr. The system prompt lists available packages.
- **Memory issues**: No explicit memory limit. For the hackathon, this is acceptable. If the code loads the full meter dataset (~800MB in memory), it will work but may be slow.

---

## Configuration

| Setting | Default | Description |
|---|---|---|
| `CODE_EXECUTION_TIMEOUT` | `30` | Maximum execution time in seconds |
| `MAX_OUTPUT_LENGTH` | `10000` | Maximum characters captured from stdout (truncated with "... [output truncated]") |
| `MAX_IMAGES` | `5` | Maximum number of matplotlib figures captured |

---

## Available Libraries

The following libraries are available in the execution environment (installed in the backend container):

- `pandas` — data manipulation
- `numpy` — numerical computing
- `matplotlib` — plotting
- `seaborn` — statistical visualization
- `scipy` — scientific computing
- `scikit-learn` — machine learning utilities
- `xgboost` — gradient boosting (for direct model inspection)
- `json`, `math`, `statistics`, `datetime`, `collections` — standard library modules
