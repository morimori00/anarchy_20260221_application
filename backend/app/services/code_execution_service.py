"""Code execution service - execute Python code generated by LLM."""
import io
import sys
import base64
import logging
import threading
import traceback
from contextlib import redirect_stdout, redirect_stderr

logger = logging.getLogger(__name__)

MAX_OUTPUT_LENGTH = 10000
TIMEOUT_SECONDS = 30


class CodeExecutionService:
    def __init__(self, data_dir: str = "/app/data"):
        self._data_dir = data_dir

    def execute(self, code: str) -> dict:
        """Execute Python code and capture output, stderr, and matplotlib figures."""
        stdout_buf = io.StringIO()
        stderr_buf = io.StringIO()
        images: list[str] = []
        exit_code = 0

        # Build execution namespace with pre-imported libraries
        namespace = {"__builtins__": __builtins__}
        try:
            import pandas as pd
            import numpy as np
            namespace["pd"] = pd
            namespace["np"] = np
            namespace["DATA_DIR"] = self._data_dir
        except ImportError:
            pass

        try:
            import matplotlib
            matplotlib.use("Agg")
            import matplotlib.pyplot as plt
            namespace["plt"] = plt
            namespace["matplotlib"] = matplotlib
        except ImportError:
            pass

        try:
            import seaborn as sns
            namespace["sns"] = sns
        except ImportError:
            pass

        try:
            import scipy
            namespace["scipy"] = scipy
        except ImportError:
            pass

        result = {"stdout": "", "stderr": "", "exitCode": 0, "images": []}
        exception_info = [None]

        def run():
            nonlocal exit_code
            try:
                with redirect_stdout(stdout_buf), redirect_stderr(stderr_buf):
                    exec(code, namespace)
            except Exception:
                exception_info[0] = traceback.format_exc()
                exit_code = 1

        thread = threading.Thread(target=run, daemon=True)
        thread.start()
        thread.join(timeout=TIMEOUT_SECONDS)

        if thread.is_alive():
            result["stderr"] = "Execution timed out (30 seconds)"
            result["exitCode"] = 1
            return result

        # Capture matplotlib figures
        try:
            import matplotlib.pyplot as plt
            for fig_num in plt.get_fignums():
                fig = plt.figure(fig_num)
                buf = io.BytesIO()
                fig.savefig(buf, format="png", bbox_inches="tight", dpi=100)
                buf.seek(0)
                b64 = base64.b64encode(buf.read()).decode("utf-8")
                images.append(f"data:image/png;base64,{b64}")
                buf.close()
            plt.close("all")
        except Exception:
            pass

        stdout_str = stdout_buf.getvalue()
        stderr_str = stderr_buf.getvalue()
        if exception_info[0]:
            stderr_str = (stderr_str + "\n" + exception_info[0]).strip()

        # Truncate long outputs
        if len(stdout_str) > MAX_OUTPUT_LENGTH:
            stdout_str = stdout_str[:MAX_OUTPUT_LENGTH] + "\n... (output truncated)"
        if len(stderr_str) > MAX_OUTPUT_LENGTH:
            stderr_str = stderr_str[:MAX_OUTPUT_LENGTH] + "\n... (output truncated)"

        result["stdout"] = stdout_str
        result["stderr"] = stderr_str
        result["exitCode"] = exit_code
        result["images"] = images

        return result
