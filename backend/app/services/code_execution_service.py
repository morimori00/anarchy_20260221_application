"""Code execution service - execute Python code generated by LLM."""

import io
import base64
import logging
import threading
import time
import traceback
from contextlib import redirect_stdout, redirect_stderr
from dataclasses import dataclass

logger = logging.getLogger(__name__)

MAX_OUTPUT_LENGTH = 10_000
MAX_IMAGES = 5
TIMEOUT_SECONDS = 30


@dataclass
class DataContext:
    """Provides convenient access to data file paths."""

    data_dir: str
    meter_sept: str
    meter_oct: str
    buildings: str
    weather: str


class CodeExecutionService:
    def __init__(self, data_dir: str = "/app/data"):
        self._data_dir = data_dir
        self._data_context = DataContext(
            data_dir=data_dir,
            meter_sept=f"{data_dir}/meter-data-sept-2025.csv",
            meter_oct=f"{data_dir}/meter-data-oct-2025.csv",
            buildings=f"{data_dir}/building_metadata.csv",
            weather=f"{data_dir}/weather-sept-oct-2025.csv",
        )

    def execute(self, code: str, timeout: int = TIMEOUT_SECONDS) -> dict:
        """Execute Python code and capture stdout, stderr, matplotlib figures."""
        stdout_buf = io.StringIO()
        stderr_buf = io.StringIO()
        images: list[str] = []
        exit_code = 0
        start_time = time.monotonic()

        # Build execution namespace with pre-imported libraries
        namespace: dict = {
            "__builtins__": __builtins__,
            "data": self._data_context,
            "DATA_DIR": self._data_dir,
        }

        try:
            import pandas as pd
            import numpy as np

            namespace["pd"] = pd
            namespace["np"] = np
        except ImportError:
            pass

        try:
            import matplotlib

            matplotlib.use("Agg")
            import matplotlib.pyplot as plt

            namespace["plt"] = plt
            namespace["matplotlib"] = matplotlib
        except ImportError:
            pass

        try:
            import seaborn as sns

            namespace["sns"] = sns
        except ImportError:
            pass

        try:
            import scipy

            namespace["scipy"] = scipy
        except ImportError:
            pass

        try:
            import xgboost

            namespace["xgboost"] = xgboost
        except ImportError:
            pass

        exception_info: list[str | None] = [None]

        def run():
            nonlocal exit_code
            try:
                with redirect_stdout(stdout_buf), redirect_stderr(stderr_buf):
                    exec(code, namespace)
            except Exception:
                exception_info[0] = traceback.format_exc()
                exit_code = 1

        thread = threading.Thread(target=run, daemon=True)
        thread.start()
        thread.join(timeout=timeout)

        execution_time = time.monotonic() - start_time

        if thread.is_alive():
            return {
                "stdout": "",
                "stderr": f"Execution timed out after {timeout} seconds",
                "exitCode": 1,
                "images": [],
                "executionTime": round(execution_time, 2),
            }

        # Capture matplotlib figures (up to MAX_IMAGES)
        try:
            import matplotlib.pyplot as plt

            fig_nums = plt.get_fignums()[:MAX_IMAGES]
            for fig_num in fig_nums:
                fig = plt.figure(fig_num)
                buf = io.BytesIO()
                fig.savefig(buf, format="png", bbox_inches="tight", dpi=100)
                buf.seek(0)
                b64 = base64.b64encode(buf.read()).decode("utf-8")
                images.append(f"data:image/png;base64,{b64}")
                buf.close()
            plt.close("all")
        except Exception:
            pass

        stdout_str = stdout_buf.getvalue()
        stderr_str = stderr_buf.getvalue()
        if exception_info[0]:
            stderr_str = (stderr_str + "\n" + exception_info[0]).strip()

        # Truncate long outputs
        if len(stdout_str) > MAX_OUTPUT_LENGTH:
            stdout_str = stdout_str[:MAX_OUTPUT_LENGTH] + "\n... [output truncated]"
        if len(stderr_str) > MAX_OUTPUT_LENGTH:
            stderr_str = stderr_str[:MAX_OUTPUT_LENGTH] + "\n... [output truncated]"

        return {
            "stdout": stdout_str,
            "stderr": stderr_str,
            "exitCode": exit_code,
            "images": images,
            "executionTime": round(execution_time, 2),
        }
